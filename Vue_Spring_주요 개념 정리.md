# 주요 개념 정리**



**#####  1. JWT (JSON Web Token)**



 **-** 속성 정보를 JSON 데이터 구조로 표현한 토큰

 **-** RFC7519 표준

 **-** 서버와 클라이언트 간 정보를 주고받을 때 사용

  **-** Http Request 헤더에 JSON 토큰을 넣고, 서버에서 헤더에 있는 토큰을 통해 정보 인증



**-** 인증 과정

 **1.** 클라이언트에서 사용자가 인증을 시도한다.

 **2.** 맞는 인증 정보를 입력하면, 서버에서는 Access Token을 발급하고 클라이언트에 전달한다.

 **3.** 클라이언트는 토큰을 로컬 스토리지에 저장하고, 서버에 요청할 때 마다 헤더에 토큰을 실어 같이 보낸다.

 **4.** 토큰이 없거나, 만료된 토큰이라면 인증에 실패한다.



**-** 장점

 **1.** 멀티 디바이스 클라이언트를 대응하는 데 부담이 없다.

 **2.** 클라이언트가 토큰 정보를 갖고 있기 때문에 서버를 Scale-Up 하는데 부담이 적다.

 **3.** 클라이언트 세션 관리에 대한 서버의 메모리 부담을 줄일 수 있다.

 **4.** 다양한 도메인을 대응하는데에 부담이 적다.



**-** 단점

 **1.** 클라이언트의 토큰 정보가 탈취된다면 보안에 취약하다.

 **2.** 토큰에 부가적인 정보가 담겨있어, 서버와 클라이언트 간 주고 받는 데이터가 세션 기반의 인증보다 많다.

 **3.** 토큰 인증을 위해 Database를 매번 조회해야 하므로 DB에 성능 부하가 올 수 있다.



**-** 참고

 **-** http://www.opennaru.com/opennaru-blog/jwt-json-web-token/



**##### 2. JPA (Java Persistence API)**



**-** 자바 ORM 기술에 대한 표준 명세

**-** 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스

**-** ORM이기 때문에 자바 클래스와 DB 테이블을 매핑한다.

**-** 동작 방식

 **-** 애플리케이션과 JDBC 사이에서 동작한다.

 **-** 개발자가 JPA를 사용하면, JPA 내부에서 JDBC API를 사용하여 SQL을 호출해 DB와 통신한다.

**-** 장점

 **-** 데이터를 객체지향적으로 관리할 수 있어 개발자는 비즈니스 로직에 집중하여 개발할 수 있다.

 **-** 생산성이 증가: 간단한 메소드로 CRUD가 가능하다. 

 **-** 유지보수성 증가: 기존에는 필드 변경 시 모든 SQL을 수정해야 했지만 JPA를 이용하면 필드만 추가하면 된다.

**-** 단점

 **-** DB 쿼리로만 처리하는 것에 비해 설계 복잡도가 높다.

 **-** 복잡한 DB 쿼리가 필요한 경우에는 성능 이슈가 발생하기 쉽다. 이를 해결하기 위해 높은 이해도가 필요하다.

**-** 참고

 **-** https://velog.io/@adam2/JPA%EB%8A%94-%EB%8F%84%EB%8D%B0%EC%B2%B4-%EB%AD%98%EA%B9%8C-orm-%EC%98%81%EC%86%8D%EC%84%B1-hibernate-spring-data-jpa



**##### 3. ORM**



**-** DB의 테이블 및 필드와 객체 간 매핑하는 방식이다.



**-** DB테이블과 자바 객체간의 관계를 바탕으로 SQL을 자동으로 생성한다.



 \```

 \###### 참고

 

 Mapper

 

 \- SQL과 자바 객체를 매핑한다. 그러므로 SQL를 직접 작성해야한다.

 \- ORM은 RDB 관계를 Object에 반영하는 것이 목적이라면, Mapper는 단순히 필드를 매핑시키는 것이 목적이다.

 \```



 



**##### 4. Hibernate**



**-** JPA를 구현한 ORM 프레임워크

**-** JPA를 기반으로 ORM을 사용하기 위한 실제 기능들을 구현한 인터페이스 모음



**##### 5. QueryDSL**



**-** 정적 타입으로 SQL 쿼리를 생성할 수 있게 해주는 프레임워크



**-** 원리



 **-** @Entity가 선언된 클래스들을 Q class라는 QueryDSL 전용 객체를 만든다.



 **-** JPAQueryFactory에 엔티티 매니저를 넣고, Q class를 가지고 자바 내에서 쿼리를 코드 방식으로 짤 수 있다.



  \```

  JPAFactoryQuery query = new JPAQueryFactory(em);

  QMember m = QMember.member;

  

  List<Member> list = query.selectFrom(m).where(m.age.gt(18)).orderBy(m.name.desc()).fetch();

  \```



**-** 장점



 **-** SQL이나 JPQL은 문자열이라 타입체크가 불가능하지만, QueryDSL은 컴파일 시점에 문법 오류를 발견할 수 있다.

 **-** IDE의 도움으로 코드를 자동완성할 수 있다.

 **-** 단순하고 쉽다.

 **-** 동적 쿼리를 생성할 수 있다.



**-** 단점



 **-** 초기 세팅이 조금 번거롭다.



**-** 참고



 **-** https://ict-nroo.tistory.com/117



**##### 6. Lombok**



**-** Class의 Getter, Setter를 일일이 작성해주지 않고, @Getter, @Setter 어노테이션만 작성해준다면 자동으로 생성해주는 라이브러리



**##### 7. Maven**



**-** Java용 프로젝트 관리 도구

**-** 빌드 중인 프로젝트, 빌드 순서, 다양한 외부 라이브러리 종속성 관계를 pom.xml에 명시한다.

**-** 외부 저장소에서 필요한 라이브러리와 플러그인을 다운로드 한 다음, 로컬 시스템의 캐시에 모두 저장한다.

**-** 크게 Clean, Build, Site 세가지 라이프 사이클로 나눈다.

**-** 참조

 **-** https://hyojun123.github.io/2019/04/18/gradleAndMaven/



**##### 8. Gradle**



**-** Maven은 XML로 라이브러리를 정의, 활용 하고있지만, Gradle에서는 별도의 빌드 스크립트를 통하여 사용할 어플리케이션 버전, 라이브러리 등의 항목을 설정한다.

**-** 스크립트 언어로 구성되어 있어 if, else, for 등의 로직 구현이 가능하다.

**-** 요즘은 Gradle을 많이 사용하는 추세이다.

**-** 장점

 **-** Build라는 동적인 요소를 XML로 정의하기에는 어려운 부분이 많다.

 **-** Groovy를 사용하므로, 동적인 빌드는 Groovy 스크립트로 호출하거나 직접 코드를 짜면 된다.

 **-** Maven보다 최대 100배 빠르다.



**-** 참조

 **-** https://hyojun123.github.io/2019/04/18/gradleAndMaven/



**##### 9. Vue 3**



**-** Vue의 최신 버전



**-** 주요 변화



 **-** 어플리케이션 인스턴스 생성



  **-** 기존에는 new Vue 방식을 통해 인스턴스를 생성했지만, createApp 함수를 통해 인스턴스 생성하는 방식으로 변경되었다.

  **-** Vue 3를 지원하는 여러 의존 라이브러리는 Vue 3를 지원한다는 것을 명시적으로 알리기 위해 이러한 방식을 사용하는 편이다.



 **-** Fragments



  **-** <template> 내에는 무조건 단일 루트 요소가 있어야 했지만(ex: 최상위에 꼭 <div> 하나만 놓기), 이제는 여러개의 요소가 선언이 가능하다.



 **-** Composition API



  **-** 기존에는 props, data, methods가 같은 depth에서 선언이 가능하고, data를 Object로 선언했지만, Vue 3 에서는 setup()을 활용하여 선언한다.



  **-** 기존의 data, methods의 사용이 가능하나 data는 함수로만 선언이 가능하다.



  **-** 코드 가독성, 유지모수성, 재사용성이 높아졌다.



  **-** 라이프 사이클 훅 접근 방법



   **-** 접두사 on을 추가하여 컴포넌트의 라이프 사이클 훅에 접근할 수 있다.



​    (ex: onBeforeMount)



   **-** beforeCreate와 create는 setup()에서 불필요하다.



 **-** this에서 props와 emit을 분리



  **-** props와 emit을 더 이상 this로 접근하지 않고, Composition API의 setup()에서 props와 emit을 명시적으로 전달 인자로 선언해야 한다.



 **-** 컴포넌트 Lifecycle의 변화



  **-** Vue 2

![](https://raw.githubusercontent.com/BaekYuri/images/main/img/lifecycle_vue2.png)

  **-** Vue 3

![](https://raw.githubusercontent.com/BaekYuri/images/main/img/lifecycle_vue3.png)



**##### 10. Element Plus**



**-** Vue 3 기반 데스크탑 UI 라이브러리

**-** Vuetify보다 지원하는 컴포넌트의 개수가 많아 활용하기 좋다.



**##### 11. Vuex**



**-** Vue 애플리케이션에 대한 상태 관리 패턴 + 라이브러리

**-** 여러 뷰에서 동일한 변수, 함수를 사용할 때, 뷰마다 같은 내용을 복사하거나 데이터 전달을 여러번 거치면서 사용하면 유지보수하기 어렵다.

**-** Vuex는 컴포넌트 간 데이터 전달을 명시하고, 여러개의 컴포넌트에서 같은 데이터를 업데이트 하기 쉽게 만든다.



**-** State(상태), Getters, Mutation(Setter), Actions(Methods)를 가질 수 있고, 모듈화를 해 용도별로 나눌수도 있다.